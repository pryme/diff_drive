#! /usr/bin/env python
from __future__ import division

import rospy
from math import pi, atan2
from geometry_msgs.msg import Twist, PoseStamped
from nav_msgs.msg import Odometry
from std_msgs.msg import Float32, Bool, Int16

from diff_drive import goal_controller
from diff_drive import pose

class GoToGoalNode:

    def __init__(self):
        self.controller = goal_controller.GoalController()

    def main(self):
        rospy.init_node('diff_drive_go_to_goal')
        self.distPub = rospy.Publisher('~distance_to_goal',
                                       Float32, queue_size=10)
        self.twistPub = rospy.Publisher('cmd_vel',
                                        Twist, queue_size=10)
        self.atGoalPub = rospy.Publisher('at_goal', Bool, queue_size = 1)

        self.nodeName = rospy.get_name()
        rospy.loginfo("{0} started".format(self.nodeName))

        rospy.Subscriber('odom', Odometry, self.odomCallback)
        rospy.Subscriber('move_base_simple/goal', PoseStamped, self.goalCallback)
        rospy.Subscriber('cliff_status', Int16, self.cliffCallback) 

        self.rate = rospy.get_param('~rate', 10.0)
        self.dT = 1 / self.rate
        self.kP = rospy.get_param('~kP', 0.3)
        self.kA = rospy.get_param('~kA', 1.0)
        self.kB = rospy.get_param('~kB', -0.1)
        self.linearTolerance = rospy.get_param('~linear_tolerance', 0.05)
        self.angularTolerance = rospy.get_param('~angular_tolerance',
                                                3/180*pi)
        rospy.logwarn('linearTolerance: {}; angularTolerance: {}'.format(self.linearTolerance,
            self.angularTolerance))  # TODO debug
        self.maxLinearSpeed = rospy.get_param('~max_linear_speed', 0.20)
        self.minLinearSpeed = rospy.get_param('~min_linear_speed', 0.02)
        self.maxAngularSpeed = rospy.get_param('~max_angular_speed', 1.0)
        self.minAngularSpeed = rospy.get_param('~min_angular_speed', 0.1)
        self.timeout = float(rospy.get_param('~timeout', 3.0))  
        self.fresh_goal = False                                

        # for test, force kP, kA, kB TODO
        #~ self.kP = 0.3
        #~ self.kA = 1.0
        #~ self.kB = -0.1
        #~ self.linearTolerance = 0.05
        #~ self.angularTolerance = 0.1
        
        self.controller.setConstants(self.kP, self.kA, self.kB)
        self.controller.setLinearTolerance(self.linearTolerance)
        self.controller.setAngularTolerance(self.angularTolerance)
        self.controller.setMaxLinearSpeed(self.maxLinearSpeed)
        self.controller.setMinLinearSpeed(self.minLinearSpeed)
        self.controller.setMaxAngularSpeed(self.maxAngularSpeed)
        self.controller.setMinAngularSpeed(self.minAngularSpeed)

        self.initPose()
        self.goal = None
        self.forward = True  # True --> goal initially in forward half-plane else goal initially in rearward h-p
        
        self.lastGoalTime = None
        rate = rospy.Rate(self.rate)
        self.lastTwistTime = rospy.get_time()
        while not rospy.is_shutdown():
            self.publish()
            rate.sleep()

    def initPose(self):
        self.pose = pose.Pose()
        self.pose.x = 0
        self.pose.y = 0
        self.pose.theta = 0

    def publish(self):
        if (self.lastGoalTime is not None and 
            rospy.get_time() - self.lastGoalTime < self.timeout):
            # either at goal or moving to goal
            if self.at_cliff:
                desired = pose.Pose()
                self.fresh_goal = False
            elif self.controller.atGoal(self.pose, self.goal, self.forward):
                desired = pose.Pose()
                if self.fresh_goal:
                    self.atGoalPub.publish(True)
                self.fresh_goal = False
            else:
                # TODO do we need to publish atGoal False?
                desired = self.controller.getVelocity(self.pose, self.goal,
                                                      self.forward)

            d = self.controller.getGoalDistance(self.pose, self.goal)
            self.distPub.publish(d)

            twist = Twist()
            twist.linear.x = desired.xVel
            twist.angular.z = desired.thetaVel
            
        else:  # timed out or no goal
            twist = Twist()  # empty to stop
            
        self.twistPub.publish(twist)

    def odomCallback(self, newPose):
        self.pose = pose.Pose()
        pos = newPose.pose.pose.position
        orientation = newPose.pose.pose.orientation
        self.pose.x = pos.x
        self.pose.y = pos.y
        self.pose.theta = atan2(2*(orientation.w * orientation.z), 1 - 2 * orientation.z**2)

    def goalCallback(self, goal):
        self.lastGoalTime = rospy.get_time()
        self.at_cliff = False
        self.fresh_goal = True
        self.goal = pose.Pose()
        pos = goal.pose.position
        orientation = goal.pose.orientation
        self.goal.x = pos.x
        self.goal.y = pos.y
        self.goal.theta = atan2(2*(orientation.w * orientation.z), 
            1 - 2 * orientation.z**2)
        # set the fwd/rev direction
        alpha = -self.pose.theta + atan2(self.goal.y - self.pose.y, 
            self.goal.x - self.pose.x)
        alpha = self.normalize_angle(alpha)
        if alpha < pi/2 and alpha >= -pi/2:
            self.forward = True
        else:
            self.forward = False
        
    def cliffCallback(self, msg):        
        # self.cliff_status = msg?
        self.at_cliff = msg.data & 0x00001000  # if bit 12 set, motion stopped by cliff
                    
    def normalize_angle(self, a):
        """Normalizes an angle to range (-pi, pi].
        
        Args:
            a: An angle in radians.
            
        Returns:
            Normalized angle in radians in range (-pi, pi].
        """
        a = a % (2 * pi)
        if a > pi:
            a -= 2 * pi
        return(a)

if __name__ == '__main__':
    try:
        node = GoToGoalNode()
        node.main()
    except rospy.ROSInterruptException:
        pass
